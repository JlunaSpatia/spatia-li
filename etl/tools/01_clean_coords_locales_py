import pandas as pd
import geopandas as gpd
import numpy as np
import os
import warnings

# --- CONFIGURACIÃ“N ---
FILE_LOCALES_RAW = "data/raw/locales202512.csv"
FILE_ACTIVIDAD_RAW = "data/raw/actividadeconomica202512.csv"
OUTPUT_MASTER = "data/raw/MADRID_MASTER_CENSUS.csv"

CRS_ORIGEN = "EPSG:25830"  # ETRS89 / UTM 30N
CRS_DESTINO = "EPSG:4326"  # WGS84

warnings.filterwarnings("ignore")


def clean_number_madrid(val):
    """Convierte formatos espaÃ±oles/mixtos a float sin cargarse decimales."""
    if pd.isna(val):
        return np.nan

    s = str(val).strip()
    if s == "":
        return np.nan

    if "." in s and "," in s:
        s = s.replace(".", "")
        s = s.replace(",", ".")
    elif "," in s:
        s = s.replace(",", ".")

    try:
        return float(s)
    except Exception:
        return np.nan


def read_smart_csv(path):
    if not os.path.exists(path):
        print(f"âŒ ERROR: No encuentro {path}")
        return None

    attempts = [
        (";", "latin-1"),
        (";", "utf-8"),
        (",", "utf-8"),
        (",", "latin-1"),
    ]
    for sep, enc in attempts:
        try:
            df = pd.read_csv(
                path, sep=sep, encoding=enc, dtype=str, on_bad_lines="skip"
            )
            if len(df.columns) > 1:
                print(f"   âœ… LeÃ­do {path} con sep='{sep}' y encoding='{enc}'")
                return df
        except Exception:
            continue

    print(f"âŒ No se ha podido leer {path} con los intentos estÃ¡ndar.")
    return None


def prepare_coordinates(df, tag):
    """Limpia coordenadas y genera BEST_X_*, BEST_Y_*."""
    print(f"   âš™ï¸ Preparando coordenadas para {tag}...")

    cx_loc = next((c for c in df.columns if "coordenada_x_local" in c.lower()), None)
    cy_loc = next((c for c in df.columns if "coordenada_y_local" in c.lower()), None)
    cx_agr = next((c for c in df.columns if "coordenada_x_agrup" in c.lower()), None)
    cy_agr = next((c for c in df.columns if "coordenada_y_agrup" in c.lower()), None)

    if not cx_loc or not cy_loc:
        print("   âš ï¸ No se han encontrado columnas de coordenadas de local.")
        return df

    df["x_loc"] = df[cx_loc].apply(clean_number_madrid)
    df["y_loc"] = df[cy_loc].apply(clean_number_madrid)

    if cx_agr and cy_agr:
        df["x_agr"] = df[cx_agr].apply(clean_number_madrid)
        df["y_agr"] = df[cy_agr].apply(clean_number_madrid)
    else:
        df["x_agr"], df["y_agr"] = np.nan, np.nan

    valid_loc = (df["x_loc"] > 1000) & (df["y_loc"] > 1000)

    df[f"BEST_X_{tag}"] = np.where(valid_loc, df["x_loc"], df["x_agr"])
    df[f"BEST_Y_{tag}"] = np.where(valid_loc, df["y_loc"], df["y_agr"])

    return df


def run_master_pipeline():
    print("ðŸš€ INICIANDO GENERACIÃ“N MADRID_MASTER_CENSUS...")

    # 1. CARGA
    df_loc = read_smart_csv(FILE_LOCALES_RAW)
    df_act = read_smart_csv(FILE_ACTIVIDAD_RAW)

    if df_loc is None:
        print("âŒ No se ha podido cargar locales. Abortando.")
        return

    # Normalizamos id_local
    col_id_loc = next(c for c in df_loc.columns if "id_local" in c.lower())
    df_loc = df_loc.rename(columns={col_id_loc: "id_local"})

    if df_act is not None:
        col_id_act = next(c for c in df_act.columns if "id_local" in c.lower())
        df_act = df_act.rename(columns={col_id_act: "id_local"})
    else:
        print("âš ï¸ No hay fichero de actividad, seguiremos solo con locales.")
        df_act = None

    # 2. COORDENADAS
    df_loc = prepare_coordinates(df_loc, "LOC")

    if df_act is not None:
        df_act = prepare_coordinates(df_act, "ACT")

        # Aseguramos que existen exactamente estas columnas en ACTIVIDAD
        for col in ["desc_seccion", "desc_division"]:
            if col not in df_act.columns:
                print(f"âš ï¸ En ACTIVIDAD no se encuentra la columna '{col}'")

        act_cols = ["id_local", "BEST_X_ACT", "BEST_Y_ACT"]
        if "desc_seccion" in df_act.columns:
            act_cols.append("desc_seccion")
        if "desc_division" in df_act.columns:
            act_cols.append("desc_division")

        act_lookup = (
            df_act[df_act["BEST_X_ACT"] > 1000][act_cols]
            .drop_duplicates("id_local")
        )
    else:
        act_lookup = pd.DataFrame(columns=["id_local", "BEST_X_ACT", "BEST_Y_ACT"])

    # 3. MERGE LOCALES + ACTIVIDAD
    print("   ðŸš‘ Cruzando ficheros (Locales + Actividad)...")
    merged = df_loc.merge(
        act_lookup,
        on="id_local",
        how="left",
        suffixes=("", "_act"),  # por si locales tambiÃ©n tuviera esas columnas
    )

    # Coordenadas finales: priorizamos LOC, si no hay tiramos de ACT
    loc_ok = merged["BEST_X_LOC"] > 1000
    merged["FINAL_X"] = np.where(loc_ok, merged["BEST_X_LOC"], merged["BEST_X_ACT"])
    merged["FINAL_Y"] = np.where(loc_ok, merged["BEST_Y_LOC"], merged["BEST_Y_ACT"])

    # 4. FILTRO ESPACIAL BÃSICO (rango razonable Madrid en UTM 30N)
    df_geo = merged[
        (merged["FINAL_X"].between(350000, 550000))
        & (merged["FINAL_Y"].between(4400000, 4500000))
    ].copy()

    print(f"   ðŸ“Š Locales georreferenciados finales: {len(df_geo):,}")

    # 5. ACTIVIDAD: desc_seccion y desc_division DESDE ACTIVIDAD
    # Tras el merge, si habÃ­a conflicto de nombres:
    #  - de ACTIVIDAD se llamarÃ¡n 'desc_seccion_act' / 'desc_division_act'
    #  - si solo existen en ACTIVIDAD, se quedan como 'desc_seccion' / 'desc_division'
    seccion_act_col = None
    division_act_col = None

    if "desc_seccion_act" in df_geo.columns:
        seccion_act_col = "desc_seccion_act"
    elif "desc_seccion" in df_geo.columns:
        seccion_act_col = "desc_seccion"

    if "desc_division_act" in df_geo.columns:
        division_act_col = "desc_division_act"
    elif "desc_division" in df_geo.columns:
        division_act_col = "desc_division"

    if seccion_act_col:
        df_geo["desc_seccion"] = df_geo[seccion_act_col]
    else:
        df_geo["desc_seccion"] = ""

    if division_act_col:
        df_geo["desc_division"] = df_geo[division_act_col]
    else:
        df_geo["desc_division"] = ""

    # 6. PROYECCIÃ“N A WGS84
    print("\nðŸ“Š DEBUG COORDENADAS UTM FINALES")
    print("   Min X:", df_geo["FINAL_X"].min(), " Max X:", df_geo["FINAL_X"].max())
    print("   Min Y:", df_geo["FINAL_Y"].min(), " Max Y:", df_geo["FINAL_Y"].max())
    print("   Media X:", df_geo["FINAL_X"].mean(), " Media Y:", df_geo["FINAL_Y"].mean())

    print(f"\n   ðŸŒ Proyectando {CRS_ORIGEN} -> {CRS_DESTINO}...")
    gdf = gpd.GeoDataFrame(
        df_geo,
        geometry=gpd.points_from_xy(df_geo["FINAL_X"], df_geo["FINAL_Y"]),
        crs=CRS_ORIGEN,
    )
    gdf = gdf.to_crs(CRS_DESTINO)

    df_geo["lon"] = gdf.geometry.x
    df_geo["lat"] = gdf.geometry.y

    df_geo = df_geo.replace([np.inf, -np.inf], np.nan)
    df_geo = df_geo.dropna(subset=["lat", "lon"])

    # 7. GUARDAR MASTER (incluyendo las 2 columnas de actividad)
    keep_cols = [
        "id_local",
        "rotulo",
        "desc_situacion_local",
        "desc_barrio_local",
        "desc_seccion",
        "desc_division",
        "lat",
        "lon",
    ]
    final_cols = [c for c in keep_cols if c in df_geo.columns]

    print(f"\n   ðŸ’¾ Guardando MASTER en: {OUTPUT_MASTER}")
    df_geo[final_cols].to_csv(OUTPUT_MASTER, index=False, sep=";", encoding="utf-8")
    print("âœ… Â¡MASTER generado con desc_seccion y desc_division!")


if __name__ == "__main__":
    run_master_pipeline()
